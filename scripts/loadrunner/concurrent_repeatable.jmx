<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0" jmeter="5.1.1 r1855137">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Test Plan" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.tearDown_on_shutdown">true</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="User Defined Variables" enabled="true">
        <collectionProp name="Arguments.arguments"/>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="DremioLoadTest" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="Loop Controller" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">${__P(num_users)}</stringProp>
        <stringProp name="ThreadGroup.ramp_time">${__P(users_ramp_time)}</stringProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <BeanShellSampler guiclass="BeanShellSamplerGui" testclass="BeanShellSampler" testname="BeanShell Sampler" enabled="true">
          <stringProp name="BeanShellSampler.query">import java.nio.file.Files; 
import java.nio.charset.Charset;
import org.apache.commons.io.FileUtils;
import org.apache.jmeter.services.FileServer;
//import net.minidev.json.JSONObject;

try {

	//The queries folder should be located relative to the Directory that contains the jmx file
	//Fetch parent directory of the JMX file
	projectHome = FileServer.getFileServer().getBaseDir();
	//System.out.println(&quot;${__P(query_dir)}&quot;);

	String queryDirectory = projectHome + &quot;/&quot; + &quot;${__P(query_dir)}&quot;;
	//System.out.println(queryDirectory);
	File folder = new File(queryDirectory);

	//Unique batch_id (current timestamp) is generated for each Jmeter batch execution. 
	//All queries (across all users/threads) in that batch would get the same Batch_id/Test_id

	String test_id = String.valueOf(${__P(batch_id)});
	String thread_num = String.valueOf(${__threadNum});
	String test_id_prefix = &quot;--Test-&quot; + test_id;
	String query_header_comments = test_id_prefix + &quot;|CONCURRENCY&quot; + &quot;|NumExecs-&quot; + ${__P(num_executors)} + &quot;|NumOfUsers-&quot; + ${__P(num_users)} + &quot;|#QPU-&quot; + ${__P(queries_per_user)} + &quot;|UsersRampTime(sec)-&quot; + ${__P(users_ramp_time)} + &quot;|CurrentUserID-&quot; + thread_num + &quot;|Host-&quot; + &quot;${__P(dremio_host)}&quot;+ &quot;|TestDesc-&quot; + &quot;${__P(test_description)}&quot; ;

	int numConcurrentUsers = ${__P(num_users)};

	// CTAS files directory  
	String ctas_directory = &quot;fe2.\&quot;salesforce-poc-data\&quot;.ctas_dest.test_&quot; + test_id + &quot;user_&quot; + thread_num;

	// Clear out the summary.csv file whenever we run a test with concurrency of 1, which we recommend be the first test of every run anyway
	if (numConcurrentUsers == 1) {
		FileWriter fstream = new FileWriter(&quot;../../logs/summary.csv&quot;,false);
		fstream.close();
	}
	
	log.info(&quot;------------------------------------------------------------------------------------&quot;);
	log.info(&quot;----------***   STARTING DREMIO CONCURRENCY LOAD TESTING ---&gt;  Thread:&quot; + thread_num + &quot;  ***----------&quot;);
	log.info(&quot;------------------------------------------------------------------------------------&quot;);

	File[] sqlFiles = folder.getCanonicalFile().listFiles();

	// New array of ordered queries to be executed by this thread
	// -&gt; X = &quot;queries_per_user&quot; (command line parameter)
	File[] thisThreadFiles = new File[${__P(queries_per_user)}];


	// We want a repeatable test, so that for a fixed set of source query files, and a given number of threads, we will always submit
	//    the same queries in the same order.
	// To do this, treat the array of source files as a circular queue, and offset each thread&apos;s starting point by its threadNum.
	
	// Calculate the offset spacing
	int sourceFileCount = sqlFiles.length;
	int spacing = Math.ceil((double)(sourceFileCount) / numConcurrentUsers);
	
	if (spacing &lt; 3) {
		spacing = 3;
	}
	
	//log.info(&quot;Spacing: &quot; + spacing);
	
	Arrays.sort(sqlFiles);
	
	int k = 0;
	for (int j=0; j &lt; thisThreadFiles.length; j++) {
    		k = (j + (spacing * (${__threadNum} - 1))) % sourceFileCount;
    		thisThreadFiles[j] = sqlFiles[k].getCanonicalFile();
	}

	// random generator for ctas table names
	Random rand = new Random();

	//Adding batch_id to each query, replacing placeholders for CTAS folder and CTAS table name.
	for (int i = 0; i &lt; thisThreadFiles.length; i++) {
    		File sqlFile = thisThreadFiles[i].getCanonicalFile();
	
	//Prepend to each query the unique batch_id as a comment (i.e. &quot;--TEST-123&quot;). That helps us later fetching all queries within a certain batch. 
    		//Each query is stored in a separate variable: q_1,q_2...q_n 	
   		if (sqlFile.isFile()) {
			String queryNum = sqlFile.getName().replaceAll(&quot;.sql&quot;, &quot;&quot;);
			//String orig_sql_text = FileUtils.readFileToString(sqlFile); //This call doesn&apos;t work for sym links
			String orig_sql_text = &quot;&quot;;
			String final_sql = &quot;&quot;;

			/* query header comments written in JSON, NOT parsable in Dremio yet so commented out
			JSONObject queryHeaderComments = new JSONObject();
			queryHeaderComments.appendField(&quot;testId&quot;, test_id);
			queryHeaderComments.appendField(&quot;queryNum&quot;, queryNum);
			queryHeaderComments.appendField(&quot;testType&quot;, &quot;CONCURRENCY&quot;);
			queryHeaderComments.appendField(&quot;numExecs&quot;, &quot;${__P(num_executors)}&quot;);
			queryHeaderComments.appendField(&quot;testDesc&quot;, &quot;${__P(test_description)}&quot;);
			queryHeaderComments.appendField(&quot;numUsers&quot;, &quot;${__P(num_users)}&quot;);
			queryHeaderComments.appendField(&quot;QPU&quot;, &quot;${__P(queries_per_user)}&quot;);
			queryHeaderComments.appendField(&quot;userRampTimeSecs&quot;, &quot;${__P(user_ramp_time)}&quot;);
			queryHeaderComments.appendField(&quot;currentUserId&quot;, thread_num);
			queryHeaderComments.appendField(&quot;host&quot;, &quot;${__P(dremio_host)}&quot;);
			queryHeaderComments.appendField(&quot;counter&quot;, String.valueOf(i));*/
			
        	List lines = Files.readAllLines(sqlFile.getCanonicalFile().toPath(), Charset.defaultCharset());
        	for (String line:lines) {
           		orig_sql_text += line + &quot;\n&quot;;
        	}
		
			// if the query is not a CTAS, Wrap the query in a select * from....limit 1000 clause in order to prevent Jmeter memory exhaustion
			if (!orig_sql_text.contains(&quot;&lt;jmeter_ctas_directory&gt;&quot;)) {
				final_sql = &quot;SELECT * FROM (&quot; + orig_sql_text + &quot;) limit 1000&quot;;
			} else {
				final_sql = orig_sql_text.replaceAll(&quot;&lt;jmeter_suffix&gt;&quot;,test_id + &quot;_&quot; + i).replaceAll(&quot;&lt;jmeter_ctas_directory&gt;&quot;,ctas_directory).replaceAll(&quot;&lt;ctas_table_name&gt;&quot;,&quot;z&quot; + String.valueOf(rand.nextInt(9999999)));
			}

     		vars.put(&quot;q_&quot; + i, &quot;--Q&quot; + queryNum + &quot; &quot; + query_header_comments + &quot;|counter-&quot; + i +  &quot;\r\n&quot; + final_sql);
			//vars.put(&quot;q_&quot; + i, &quot;--&quot; + queryHeaderComments.toString() + &quot;\r\n&quot; + final_sql);
		}
	}
}
catch (Throwable ex) {
   	log.error(&quot;concurrent_repeatable Beanshell failure: &quot;, ex);
	System.out.println(&quot;concurrent_repeatable Beanshell failure: &quot;, ex);
    	throw ex;
}</stringProp>
          <stringProp name="BeanShellSampler.filename"></stringProp>
          <stringProp name="BeanShellSampler.parameters"></stringProp>
          <boolProp name="BeanShellSampler.resetInterpreter">false</boolProp>
        </BeanShellSampler>
        <hashTree/>
        <JDBCDataSource guiclass="TestBeanGUI" testclass="JDBCDataSource" testname="Dremio-JDBC" enabled="true">
          <boolProp name="autocommit">true</boolProp>
          <stringProp name="checkQuery">select 1</stringProp>
          <stringProp name="connectionAge">5000</stringProp>
          <stringProp name="dataSource">dremiopool</stringProp>
          <stringProp name="dbUrl">jdbc:dremio:direct=${__P(dremio_host)}:31010</stringProp>
          <stringProp name="driver">com.dremio.jdbc.Driver</stringProp>
          <stringProp name="initQuery"></stringProp>
          <boolProp name="keepAlive">true</boolProp>
          <stringProp name="password">${__P(password)}</stringProp>
          <stringProp name="poolMax">${__P(num_users)}</stringProp>
          <stringProp name="timeout">10000</stringProp>
          <stringProp name="transactionIsolation">DEFAULT</stringProp>
          <stringProp name="trimInterval">60000</stringProp>
          <stringProp name="username">${__P(username)}</stringProp>
        </JDBCDataSource>
        <hashTree/>
        <ForeachController guiclass="ForeachControlPanel" testclass="ForeachController" testname="ForEach Controller" enabled="true">
          <stringProp name="ForeachController.inputVal">q</stringProp>
          <stringProp name="ForeachController.returnVal">query</stringProp>
          <boolProp name="ForeachController.useSeparator">true</boolProp>
          <stringProp name="ForeachController.startIndex">-1</stringProp>
        </ForeachController>
        <hashTree>
          <JDBCSampler guiclass="TestBeanGUI" testclass="JDBCSampler" testname="dremio query" enabled="true">
            <stringProp name="dataSource">dremiopool</stringProp>
            <stringProp name="query">${query}</stringProp>
            <stringProp name="queryArguments"></stringProp>
            <stringProp name="queryArgumentsTypes"></stringProp>
            <stringProp name="queryTimeout"></stringProp>
            <stringProp name="queryType">Select Statement</stringProp>
            <stringProp name="resultSetHandler">Count Records</stringProp>
            <stringProp name="resultVariable"></stringProp>
            <stringProp name="variableNames"></stringProp>
          </JDBCSampler>
          <hashTree/>
        </hashTree>
        <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename">../../logs/summary.csv</stringProp>
          <boolProp name="useGroupName">true</boolProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
        <ResultCollector guiclass="StatVisualizer" testclass="ResultCollector" testname="Aggregate Report" enabled="true">
          <boolProp name="ResultCollector.error_logging">false</boolProp>
          <objProp>
            <name>saveConfig</name>
            <value class="SampleSaveConfiguration">
              <time>true</time>
              <latency>true</latency>
              <timestamp>true</timestamp>
              <success>true</success>
              <label>true</label>
              <code>true</code>
              <message>true</message>
              <threadName>true</threadName>
              <dataType>true</dataType>
              <encoding>false</encoding>
              <assertions>true</assertions>
              <subresults>true</subresults>
              <responseData>false</responseData>
              <samplerData>false</samplerData>
              <xml>false</xml>
              <fieldNames>true</fieldNames>
              <responseHeaders>false</responseHeaders>
              <requestHeaders>false</requestHeaders>
              <responseDataOnError>false</responseDataOnError>
              <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
              <assertionsResultsToSave>0</assertionsResultsToSave>
              <bytes>true</bytes>
              <sentBytes>true</sentBytes>
              <url>true</url>
              <threadCounts>true</threadCounts>
              <idleTime>true</idleTime>
              <connectTime>true</connectTime>
            </value>
          </objProp>
          <stringProp name="filename"></stringProp>
        </ResultCollector>
        <hashTree/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
